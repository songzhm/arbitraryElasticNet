print(t(updateFactor)*v)
updateFactor
t(updateFactor)
v
t(updateFactor)*v
v
print(t(updateFactor)*v)
print((t(updateFactor)*v-v))
print((t(updateFactor)*v-v)^2)
print(sum(t(updateFactor)*v-v)^2))
print(sum(t(updateFactor)*v-v)^2)
print(sum((t(updateFactor)*v-v)^2))
dim(v)
size(v)
leng(v)
length(v)
t(v)
dim(t(v))
t(v)*v
v
A = matrix(c(5,-2,-1,-2,4,3,-1,3,5),byrow = TRUE,nrow = 3)
A
b = t((c(2,-35,-47)))
b
sol1 <- munqp(A,b)
dFb[i]^2+4*dFa[i]*dFc[i]
dFa
dFb
dFc
updateFactor
debugSource('C:/Users/Ming/Dropbox/statistical learning project/Numerical Method/Code/nqpSolver.R')
sol1 <- munqp(A,b)
source("nqpSolver.R")
A = matrix(c(5,-2,-1,-2,4,3,-1,3,5),byrow = TRUE,nrow = 3)
A
CA = matrix(c(0,0,0,0,0,0,0,0,0),byrow = TRUE,nrow = 3)
CA
b = t((c(2,-35,-47)))
b
sol1 <- munqp(A,b)
debugSource('C:/Users/Ming/Dropbox/statistical learning project/Numerical Method/Code/nqpSolver.R')
debugSource('C:/Users/Ming/Dropbox/statistical learning project/Numerical Method/Code/nqpSolver.R')
debugSource('C:/Users/Ming/Dropbox/statistical learning project/Numerical Method/Code/nqpSolver.R')
debugSource('C:/Users/Ming/Dropbox/statistical learning project/Numerical Method/Code/nqpSolver.R')
sol1 <- munqp(A,b)
dFa
dFb
dFc
updateFactor
updateFactor
sol1 <- munqp(A,b)
sol1
require(quadprog)
sol <- solve.QP(A,-b,CA,bvec)
sol
sol1 <- munqp(A,b)
updateFactor
dFa
dFb
dFc
v
setwd("C:/Users/Ming/Dropbox/statistical learning project/Numerical Method/Code/dev")
source("nqpSover.R")
source("nqpSolver.R")
data = read.csv("sp500compdata.csv")
data$Date
as.Date(data$Date, format ="%Y-%m-%d")
data$Date=as.Date(data$Date, format ="%Y-%m-%d")
data$Date
end= as.Date("2015-12-31", format ="%Y-%m-%d")
subdata = data[start<=data$Date<=end,]
subdata = data[start<=data$Dat,]
class(data)
subdata = data[start<=data$Dat]
subdata = data[data$Date>=start]
data$Date>=start
subdata = data[data$Date>start]
start
stat_date= as.Date("2013-01-01", format ="%Y-%m-%d")
end_date= as.Date("2015-12-31", format ="%Y-%m-%d")
stat_date
end_date
subdata = data[data$Date>=start_date]
start_date= as.Date("2013-01-01", format ="%Y-%m-%d")
end_date= as.Date("2015-12-31", format ="%Y-%m-%d")
subdata = data[data$Date>=start_date]
subdata = data[data$Date>=start_date,]
subdata = data[data$Date>=start_date and data$Date<=end_date,]
subdata = data[data$Date>=start_date | data$Date<=end_date,]
subdata
subdata = data[data$Date>=start_date || data$Date<=end_date,]
subdata = data[data$Date>=start_date,]
subdata = subdata[subdata$Date<=end_date,]
View(subdata)
completeFun <- function(data) {
completeVec <- complete.cases(data[, ])
return(data[completeVec, ])
}
res = completeFun(subdata)
View(subdata)
data = read.csv("sp500compdata_2013-2015.csv")
data$Date=as.Date(data$Date, format ="%Y-%m-%d")
start_date= as.Date("2013-01-01", format ="%Y-%m-%d")
end_date= as.Date("2015-12-31", format ="%Y-%m-%d")
subdata = subdata[complete.cases(data),]
subdata
complete.cases(data)
View(data)
row.has.na <- apply(data, 1, function(x){any(is.na(x))})
data.filtered <- data[!row.has.na,]
row.has.na
row.has.na <- apply(data, 2, function(x){any(is.na(x))})
data.filtered <- data[!row.has.na,]
View(data)
data$Date
data = read.csv("sp500compdata_2013-2015.csv")
data$Date=as.Date(data$Date, format ="%Y-%m-%d")
data
View(data)
data = read.csv("sp500compdata_2013-2015.csv")
View(data)
data$Date=as.Date(data$Date, format ="%m/%d/%Y")
row.has.na <- apply(data, 1, function(x){any(is.na(x))})
data.filtered <- data[!row.has.na,]
setwd("C:/Users/Ming/Dropbox/statistical learning project/Numerical Method/Code/dev")
source("nqpSolver.R")
data = read.csv("sp500compdata_2013-2015.csv")
data$Date=as.Date(data$Date, format ="%m/%d/%Y")
row.has.na <- apply(data, 1, function(x){any(is.na(x))})
data.filtered <- data[!row.has.na,]
sp500 = read.csv("sp 500 index_2013_2015_yahoo.csv")
sp500$Date=as.Date(sp500$Date, format ="%m/%d/%Y")
sp500 = sp500[c("Date","Adjusted.Close")]
new_data = merge(data.filtered,sp500,by = c("Date"))
View(new_data)
new_data = new_data[-1]
names(new_data)
size(new_data)
dim(new_data)
l = dim(new_data)[1]
l
rates = (new_data[2:l,]-new_data[1:l-1,])/new_data[1:l-1,]
rates
require(caret)
install.packages("caret")
require(caret)
flds <- createFolds(rates, k = 10, list = TRUE, returnTrain = FALSE)
flds
flds[[1]]
flds <- createFolds(rates, k = 10, list = TRUE, returnTrain = True)
flds <- createFolds(rates, k = 10, list = TRUE, returnTrain = TRUE)
flds <- createFolds(rates, k = 10, list = TRUE, returnTrain = FALSE)
?createFolds
flds <- createFolds(rates, k = 10, list = TRUE, returnTrain = FALSE)
flds
?createFolds
flds <- createFolds(rates, k = 10, p = 20,list = TRUE, returnTrain = FALSE)
flds <- createFolds(rates, k = 10, p = 0.2,list = TRUE, returnTrain = FALSE)
testing1 = flds[[1]]
testing1
len(testing1)/l
length(testing1)/l
testing2 = flds[[2]]
length(testing2)/l
length(flds[[3]])/l
length(flds[[4]])/l
length(flds[[5]])/l
length(flds[[6]])/l
length(flds[[7]])/l
length(flds[[8]])/l
length(flds[[9]])/l
createFolds
?cut
floor(length(rates)/k)
floor(length(rates)/10)
probs = seq(0, 1, length = cuts)
probs = seq(0, 1, length = 5)
probs
testing1
training_data = rates[-testing1,]
testing_data = rates[testing1,]
alpha = seq(0,1,0.1)
alpha
lambda_grid = seq(0,1,0.1)
alpha_grid = seq(0,1,0.1)
para_grid = apply(expand.grid(lambda_grid,alpha_grid), 1, function(x) c(x[1],x[2]))
para_grid
lambda_grid = c(0,0.01,0.1,1,10,100,1000)
alpha_grid = seq(0,1,0.1)
para_grid = apply(expand.grid(lambda_grid,alpha_grid), 1, function(x) c(x[1],x[2]))
para_grid
source("nqpSolver.R")
A = matrix(c(5,-2,-1,-2,4,3,-1,3,5),byrow = TRUE,nrow = 3)
A
CA = matrix(c(0,0,0,0,0,0,0,0,0),byrow = TRUE,nrow = 3)
CA
b = t((c(2,-35,-47)))
b
sol1 <- munqp(A,b)
sol1
A%*%sol1
A%*%t(sol1)
sol <- solve.QP(A,-b,CA,bvec)
sol
require(quadprog)
sol <- solve.QP(A,-b,CA,bvec)
sol
sol1 <- munqp(A,b)
sol1
source("nqpSolver.R")
A = matrix(c(5,-2,-1,-2,4,3,-1,3,5),byrow = TRUE,nrow = 3)
CA = matrix(c(0,0,0,0,0,0,0,0,0),byrow = TRUE,nrow = 3)
A
CA
b = t((c(2,-35,-47)))
b
bvec = t(c(0,0,0))
require(quadprog)
sol <- solve.QP(A,-b,CA,bvec)
sol
sol1 <- munqp(A,b)
sol1
A%*%sol$solution
-A%*%sol$solution
source('C:/Users/Ming/Dropbox/statistical learning project/Numerical Method/Code/dev/uilt.R')
mse(-A%*%sol$solution,b)
b
b = t(c(2,-35,-47))
b
sol1 <- munqp(A,-b)
sol1
sol1 <- munqp(A,b)
sol1
i=1
testing_ind = flds[[i]]
training_data = rates[-testing_id,]
training_x = training_data[,1:(dim(training_data)[2]-1)]
training_data = rates[-testing_ind,]
training_x = training_data[,1:(dim(training_data)[2]-1)]
training_y = training_data[,dim(training_data)[2]]
testing_ind = flds[[i]]
training_data = rates[-testing_ind,]
training_x = training_data[,1:(dim(training_data)[2]-1)]
training_y = training_data[,dim(training_data)[2]]
testing_data = rates[testing_ind,]
testing_x = testing_data[,1:(dim(testing_data)[2]-1)]
testing_y = testing_data[,dim(testing_data)[2]]
Broswer(training_x)
View(training_x)
edit(training_x)
is.na(trainging_x)
is.na(training_x)
sum(is.na(training_x))
eye(1)
eye(5)
diag(1,3)
diag(1,x)
testing_ind = flds[[i]]
training_data = rates[-testing_ind,]
x = training_data[,1:(dim(training_data)[2]-1)]
y = training_data[,dim(training_data)[2]]
testing_data = rates[testing_ind,]
testing_x = testing_data[,1:(dim(testing_data)[2]-1)]
testing_y = testing_data[,dim(testing_data)[2]]
diag(1,x)
diag(1,nrow(x))
A = 2*(t(x)%*%x+lambda*(1-alpha)*I)
x
t(x)%*%x
x = as.matrix(training_data[,1:(dim(training_data)[2]-1)])
y = as.matrix(training_data[,dim(training_data)[2]])
testing_data = rates[testing_ind,]
testing_x = as.matrix(testing_data[,1:(dim(testing_data)[2]-1)])
testing_y = as.matrix(testing_data[,dim(testing_data)[2]])
x
y
I = diag(1,nrow(x))
j=1
k=1
lambda = lambda_grid[j]
alpha = alpha_grid[k]
I = diag(1,nrow(x))
A = 2*(t(x)%*%x+lambda*(1-alpha)*I)
t(x)%*%x
lambda*(1-alpha)*I
dim(t(x)%*%x)
dim(lambda*(1-alpha)*I)
I = diag(1,ncol(x))
A = 2*(t(x)%*%x+lambda*(1-alpha)*I)
b = lambda*x*I - 2*t(y)%*%x
A
lambda*x*I
b = lambda*alpha*I - 2*t(y)%*%x
lambda*alpha*I
dim(lambda*alpha*I)
2*t(y)%*%x
dim(2*t(y)%*%x)
b = lambda*alpha*rep(1,length(ncol(x))) - 2*t(y)%*%x
dim(b)
b
b = t(c(2,-35,-47))
b
dim(b)
sol <- munqp(A,b)
debugSource('C:/Users/Ming/Dropbox/statistical learning project/Numerical Method/Code/dev/nqpSolver.R')
sol <- munqp(A,b)
v
View(bvec)
alpha = alpha_grid[k]
I = diag(1,ncol(x))
A = 2*(t(x)%*%x+lambda*(1-alpha)*I)
b = lambda*alpha*rep(1,length(ncol(x))) - 2*t(y)%*%x
sol <- munqp(A,b)
sol <- munqp(A,b)
sol
plot(sol)
sol[sol>1e-3]
sol[sol>1e-2]
max(sol)
source("util.R")
source('C:/Users/Ming/Dropbox/statistical learning project/Numerical Method/Code/dev/uilt.R')
testing_ind <- flds[[i]]
training_data <- rates[-testing_ind,]
x <- as.matrix(cbind(rep(1,dim(training_data)[1]),training_data[,1:(dim(training_data)[2]-1)]))
y <- as.matrix(training_data[,dim(training_data)[2]])
testing_data <- rates[testing_ind,]
testing_x <- as.matrix(cbind(rep(1,dim(testing_data)[1]),testing_data[,1:(dim(testing_data)[2]-1)]))
testing_y <- as.matrix(testing_data[,dim(testing_data)[2]])
lambda <- lambda_grid[j]
alpha <- alpha_grid[k]
I <- diag(1,ncol(x))
A <- 2*(t(x)%*%x+lambda*(1-alpha)*I)
b <- lambda*alpha*rep(1,length(ncol(x))) - 2*t(y)%*%x
sol <- munqp(A,b)
source('C:/Users/Ming/Dropbox/statistical learning project/Numerical Method/Code/dev/uilt.R')
sol
dim(testing_x)
dim(sol)
length(sol)
sol <- as.matrix(munqp(A,b))
dim(sol)
source('C:/Users/Ming/Dropbox/statistical learning project/Numerical Method/Code/dev/uilt.R')
y_hat <- predict(testing_x,sol)
y_hat
y
y-y_hat
dim(y)
dim(y_hat)
testing_y_hat <- predict(testing_x,sol)
testing_y-testing_y_hat
mean((testing_y-testing_y_hat)^2)
source('C:/Users/Ming/Dropbox/statistical learning project/Numerical Method/Code/dev/uilt.R')
mse = calculateMSE(testing_y,testing_y_hat)
mse
setwd("C:/Users/Ming/Dropbox/statistical learning project/Numerical Method/Code/dev")
source("nqpSolver.R")
source("util.R")
data = read.csv("sp500compdata_2013-2015.csv")
data$Date=as.Date(data$Date, format ="%m/%d/%Y")
row.has.na <- apply(data, 1, function(x){any(is.na(x))})
data.filtered <- data[!row.has.na,]
sp500 = read.csv("sp 500 index_2013_2015_yahoo.csv")
sp500$Date=as.Date(sp500$Date, format ="%m/%d/%Y")
sp500 = sp500[c("Date","Adjusted.Close")]
new_data = merge(data.filtered,sp500,by = c("Date"))
new_data = new_data[-1]
l = dim(new_data)[1]
rates = (new_data[2:l,]-new_data[1:l-1,])/new_data[1:l-1,]
require(caret)
n_fold = 10
flds <- createFolds(rates, k = n_fold,list = TRUE, returnTrain = FALSE)
lambda_grid = c(0,0.01,0.1,1,10,100,1000)
alpha_grid = seq(0,1,0.1)
# para_grid = apply(expand.grid(lambda_grid,alpha_grid), 1, function(x) c(x[1],x[2]))
mse_table = c()
for(i in 1:length(lambda_grid)){
lambda <- lambda_grid[i]
for(j in 1: length(alpha_grid)){
alpha <- alpha_grid[j]
for (k in seq(1,n_fold,1)){
testing_ind <- flds[[k]]
training_data <- rates[-testing_ind,]
x <- as.matrix(cbind(rep(1,dim(training_data)[1]),training_data[,1:(dim(training_data)[2]-1)]))
y <- as.matrix(training_data[,dim(training_data)[2]])
testing_data <- rates[testing_ind,]
testing_x <- as.matrix(cbind(rep(1,dim(testing_data)[1]),testing_data[,1:(dim(testing_data)[2]-1)]))
testing_y <- as.matrix(testing_data[,dim(testing_data)[2]])
I <- diag(1,ncol(x))
A <- 2*(t(x)%*%x+lambda*(1-alpha)*I)
b <- lambda*alpha*rep(1,length(ncol(x))) - 2*t(y)%*%x
sol <- as.matrix(munqp(A,b))
testing_y_hat <- predict(testing_x,sol)
mse = calculateMSE(testing_y,testing_y_hat)
mse_table=rbind(mse_table,c(lambda,alpha,mse))
}
}
}
setwd("C:/Users/Ming/Dropbox/statistical learning project/Numerical Method/Code/dev")
source("nqpSolver.R")
source("uilt.R")
data = read.csv("sp500compdata_2013-2015.csv")
data$Date=as.Date(data$Date, format ="%m/%d/%Y")
row.has.na <- apply(data, 1, function(x){any(is.na(x))})
data.filtered <- data[!row.has.na,]
sp500 = read.csv("sp 500 index_2013_2015_yahoo.csv")
sp500$Date=as.Date(sp500$Date, format ="%m/%d/%Y")
sp500 = sp500[c("Date","Adjusted.Close")]
new_data = merge(data.filtered,sp500,by = c("Date"))
new_data = new_data[-1]
l = dim(new_data)[1]
rates = (new_data[2:l,]-new_data[1:l-1,])/new_data[1:l-1,]
require(caret)
n_fold = 10
flds <- createFolds(rates, k = n_fold,list = TRUE, returnTrain = FALSE)
lambda_grid = c(0,0.01,0.1,1,10,100,1000)
alpha_grid = seq(0,1,0.1)
# para_grid = apply(expand.grid(lambda_grid,alpha_grid), 1, function(x) c(x[1],x[2]))
n_total = length(lambda_grid)*length(alpha_grid)
counter = 1
mse_table = c()
for(i in 1:length(lambda_grid)){
lambda <- lambda_grid[i]
for(j in 1: length(alpha_grid)){
alpha <- alpha_grid[j]
for (k in seq(1,n_fold,1)){
testing_ind <- flds[[k]]
training_data <- rates[-testing_ind,]
x <- as.matrix(cbind(rep(1,dim(training_data)[1]),training_data[,1:(dim(training_data)[2]-1)]))
y <- as.matrix(training_data[,dim(training_data)[2]])
testing_data <- rates[testing_ind,]
testing_x <- as.matrix(cbind(rep(1,dim(testing_data)[1]),testing_data[,1:(dim(testing_data)[2]-1)]))
testing_y <- as.matrix(testing_data[,dim(testing_data)[2]])
I <- diag(1,ncol(x))
A <- 2*(t(x)%*%x+lambda*(1-alpha)*I)
b <- lambda*alpha*rep(1,length(ncol(x))) - 2*t(y)%*%x
sol <- as.matrix(munqp(A,b))
testing_y_hat <- predict(testing_x,sol)
mse = calculateMSE(testing_y,testing_y_hat)
mse_table=rbind(mse_table,c(lambda,alpha,mse))
}
print(counter/n_total)
counter=counter+1
}
}
print(mse_table)
setwd("C:/Users/Ming/Dropbox/statistical learning project/Numerical Method/Code/dev")
source("nqpSolver.R")
source("uilt.R")
data = read.csv("sp500compdata_2013-2015.csv")
data$Date=as.Date(data$Date, format ="%m/%d/%Y")
row.has.na <- apply(data, 1, function(x){any(is.na(x))})
data.filtered <- data[!row.has.na,]
sp500 = read.csv("sp 500 index_2013_2015_yahoo.csv")
sp500$Date=as.Date(sp500$Date, format ="%m/%d/%Y")
sp500 = sp500[c("Date","Adjusted.Close")]
new_data = merge(data.filtered,sp500,by = c("Date"))
new_data = new_data[-1]
l = dim(new_data)[1]
rates = (new_data[2:l,]-new_data[1:l-1,])/new_data[1:l-1,]
require(caret)
n_fold = 10
flds <- createFolds(rates, k = n_fold,list = TRUE, returnTrain = FALSE)
lambda_grid = c(0,0.01,0.1,1,10,100,1000)
alpha_grid = seq(0,1,0.1)
# para_grid = apply(expand.grid(lambda_grid,alpha_grid), 1, function(x) c(x[1],x[2]))
n_total = length(lambda_grid)*length(alpha_grid)
counter = 1
mse_table = c()
for(i in 1:length(lambda_grid)){
lambda <- lambda_grid[i]
for(j in 1: length(alpha_grid)){
alpha <- alpha_grid[j]
mses = c()
for (k in seq(1,n_fold,1)){
testing_ind <- flds[[k]]
training_data <- rates[-testing_ind,]
x <- as.matrix(cbind(rep(1,dim(training_data)[1]),training_data[,1:(dim(training_data)[2]-1)]))
y <- as.matrix(training_data[,dim(training_data)[2]])
testing_data <- rates[testing_ind,]
testing_x <- as.matrix(cbind(rep(1,dim(testing_data)[1]),testing_data[,1:(dim(testing_data)[2]-1)]))
testing_y <- as.matrix(testing_data[,dim(testing_data)[2]])
I <- diag(1,ncol(x))
A <- 2*(t(x)%*%x+lambda*(1-alpha)*I)
b <- lambda*alpha*rep(1,length(ncol(x))) - 2*t(y)%*%x
sol <- as.matrix(munqp(A,b))
testing_y_hat <- predict(testing_x,sol)
mse = calculateMSE(testing_y,testing_y_hat)
mses = c(mses,mse)
}
mse_table=rbind(mse_table,c(lambda,alpha,mean(mses)))
print(counter/n_total)
counter=counter+1
}
}
print(mse_table)
mse_table= as.data.frame(mse_table)
colnames(mse_table)=c(lambda,alpha,mse)
mse_table
colnames(mse_table)=c("lambda","alpha","mse")
mse_table
ggplot(data = mse_table,aes(x=alpha,y=mse,colour = lambda))+geom_line()
ggplot(data = mse_table,aes(x=alpha,y=mse,colour = factor(lambda)))+geom_line()
ggplot(data = mse_table,aes(x=alpha,y=mse,colour = factor(lambda)))+geom_line()+geom_point(
ggplot(data = mse_table,aes(x=alpha,y=mse,colour = factor(lambda)))+geom_line()+geom_point()
ggplot(data = mse_table,aes(x=alpha,y=mse,colour = factor(lambda)))+geom_point()
ggplot(data = mse_table,aes(x=alpha,y=mse,colour = factor(lambda)))+geom_line()+geom_point()
ggplot(data = mse_table,aes(x=alpha,y=mse,colour = factor(lambda)))+geom_line()
+geom_point()
ggplot(data = mse_table,aes(x=alpha,y=mse,colour = factor(lambda)))+geom_line()+geom_point()
colnames(mse_table)=c("lambda","alpha","avg_mse")
ggplot(data = mse_table,aes(x=alpha,y=mse,colour = factor(lambda)))+geom_line()+geom_point()
ggplot(data = mse_table,aes(x=alpha,y=avg_mse,colour = factor(lambda)))+geom_line()+geom_point()
